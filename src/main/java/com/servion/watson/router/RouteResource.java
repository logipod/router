package com.servion.watson.router;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.ParseException;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.util.EntityUtils;
import org.apache.log4j.Logger;
import org.apache.log4j.MDC;
import org.glassfish.grizzly.Buffer;
import org.glassfish.grizzly.http.server.Request;
import org.glassfish.grizzly.http.server.Response;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import com.google.gson.reflect.TypeToken;
import com.ibm.watson.developer_cloud.conversation.v1.ConversationService;
import com.ibm.watson.developer_cloud.conversation.v1.model.Intent;
import com.ibm.watson.developer_cloud.conversation.v1.model.MessageRequest;
import com.ibm.watson.developer_cloud.conversation.v1.model.MessageResponse;
import com.ibm.watson.developer_cloud.http.ServiceCall;
import com.ibm.watson.developer_cloud.util.GsonSingleton;

/**
 * @author larsen.mallick
 * 
 *         Provides a platform for customizing input and output between SIP
 *         Orchestrator and Covnersation service. Complies Proxy pattern.
 */
@Path("api")
public class RouteResource {

	private final static Logger logger = Logger.getLogger(RouteResource.class);

	private static final Map<String, String> urlsMap = new HashMap<String, String>() {
		/**
		 * Random generated serialization ID will be used. This is generated
		 * based on the class name, number of parameters. This could lead to a
		 * problem in case of a different variant of JVM is used for
		 * desiarlization.
		 */
		private static final long serialVersionUID = -6304439467917487175L;

		{
			put("identify", "http://localhost:8080/ivr.web/rest/identify?identifierNumber=%s&informationRequested=%s");
			put("getProfile", "http://localhost:8080/ivr.web/rest/getProfile?secretNumber=%s&informationRequested=%s");
			put("acctStatus", "http://localhost:8080/ivr.web/rest/acctStatus?accountNumber=%s&informationRequested=%s");
			put("logout", "http://localhost:8080/ivr.web/rest/logout");
		}
	};

	private ConversationService service = new ConversationService(ConversationService.VERSION_DATE_2016_07_11,
			"89315619-69b1-4641-a9a3-8cb29350a8cd", "usktlkSLDxUT");

	/*
	 * sessionID is used to maintain session on the business application side.
	 */
	private String sessionID = null;

	/**
	 * This method is required to do the following - 1. Get request from SIP
	 * ORchestrator 2. Parse the request body and take out input text and
	 * context 3. Re-construct MessageRequest with the input and context
	 * information from step-2 4. Invoke conversation service and get back
	 * MesssageResponse 5. From the response, get the context param -
	 * actionRequested to know if conversation requires some info from business
	 * application 6. Based on the actionRequested, hit appropriate URL to get
	 * business data 7. Construct MessageRequest object and pass on the business
	 * data to conversation service 8. To maintain session with the business
	 * application, sessionID will be included in context param
	 * 
	 * @param request
	 * @param workspaceid
	 *            - conversation workspace ID. This is generated by IBM
	 *            Conversation Studio.
	 * @param version
	 *            - not used as of now
	 * @param httpResponse
	 * @return
	 */
	@Path("/v1/workspaces/{workspaceid}/message")
	@Consumes({ MediaType.APPLICATION_JSON })
	@POST
	public String postRequest(@Context Request request, @PathParam("workspaceid") String workspaceid,
			@QueryParam("version") String version, @Context Response httpResponse) {

		/*
		 * Represents the input given by the caller. This input comes from STT
		 * -> Media Relay -> SIP Orchestrator -> Conversation Client API
		 */
		String input = null;

		/*
		 * Context object is passed back & forth between conversation client and
		 * service to maintain session
		 */
		Map<String, Object> context = null;

		/*
		 * New request message constructed from the input and context received
		 * from SIP Orchestrator. This represents a proxy to the actual request
		 * generated by SIP Orchestrator
		 */
		MessageRequest proxyRequestMsg = null;

		/*
		 * Response message returned from Conversation Service. This will be
		 * parsed to understand the action requested by the caller.
		 */
		MessageResponse conversationResponseMsg = null;

		/*
		 * Represents a synchronous call to conversation service.
		 */
		ServiceCall<MessageResponse> serviceCall = null;

		/*
		 * Indicates if business data is required. Business data is required
		 * when conversation service needs customer specific information
		 */
		boolean businessHitRequested = false;

		/*
		 * Indicates if agent transfer is requested by caller. Upon receiving
		 * agentTransferRequested = true, router service will post attach data
		 * to agent through web service.
		 */
		boolean transferRequested = false;

		/*
		 * Informs the voice gateway to initiate a transfer after the included
		 * text response is played back to the caller. *
		 */
		String vgwTransfer = "no";

		/*
		 * Indicates the API call to be executed in the business application
		 */
		String actionRequested = null;

		/*
		 * After business application hit, intent will be manipulated by the
		 * router service and sent to conversation service
		 */
		String intent = null;

		/*
		 * This indicates the status of the HTTP URL operation in order to get
		 * business data. Possible values are success or failure.
		 */
		String dataFetchResult = null;

		try {

			/*
			 * 1. Get body of the request 2. Convert request to Json 3. Get
			 * input provided by the caller and the context object
			 */
			Buffer postBody = request.getPostBody(0);

			/*
			 * Null message looks to be an error with SIP Orchestrator. This is
			 * not a retrieval option. This is only for monitoring. Since post
			 * body is empty, context will not be available to continue with the
			 * conversation.
			 */
			if (postBody.toStringContent() == null || postBody.toStringContent().isEmpty()) {
				throw new EmptyBodyException();
			}

			JsonObject requestBodyJson = GsonSingleton.getGson().fromJson(postBody.toStringContent(), JsonElement.class)
					.getAsJsonObject();
			input = requestBodyJson.getAsJsonObject("input").get("text").getAsString();
			if (requestBodyJson.getAsJsonObject("context") != null) {
				String contextAsString = requestBodyJson.getAsJsonObject("context").toString();
				context = GsonSingleton.getGson().fromJson(contextAsString, new TypeToken<HashMap<String, Object>>() {
				}.getType());
			}

			/*
			 * 1. Construct a request message based on the input and context
			 * using builder pattern since context is optional 2. Update
			 * serviceCall task with the proxy request message 3. Execute the
			 * service and get back response (synchronous call) 4. This supports
			 * - Synchronous, Asynchronous and Reactive Calls through a
			 * CompletableFuture. 5. Update the context object
			 */
			proxyRequestMsg = new MessageRequest.Builder().inputText(input).context(context).build();
			serviceCall = service.message(workspaceid, proxyRequestMsg);
			conversationResponseMsg = serviceCall.execute();
			context = conversationResponseMsg.getContext();

			/*
			 * businessHitRequested will be included included in context by
			 * conversation If true, business application hit will be performed
			 * After business application hit, this parameter will need to reset
			 * in context
			 */
			businessHitRequested = (context.get("businessHitRequested") != null)
					? (Boolean) context.get("businessHitRequested") : false;

			/*
			 * agentTransferRequested will be included included in context by
			 * conversation If true, router will pass data to agent application
			 * through web service. After web service call, this parameter will
			 * need to reset in context
			 */
			transferRequested = (context.get("transferRequested") != null) ? (Boolean) context.get("transferRequested")
					: false;

			while (businessHitRequested || transferRequested) {

				/*
				 * Look for session id in the context object. Session ID will be
				 * used to stick session with the conversation service session
				 * ID will not be available if no business application hit is
				 * performed till the point in the current conversation
				 */
				sessionID = (context.get("sessionID") != null) ? (String) context.get("sessionID") : null;

				/*
				 * Conversation service will define the action to be performed
				 * based on the caller intent Get the action requested from
				 * context object After performing the action, action requested
				 * will be either set to an empty string
				 */
				actionRequested = (context.get("actionRequested") != null) ? (String) context.get("actionRequested")
						: null;

				/*
				 * Business application URL will be invoked and requried data
				 * will be updated in context while the method returns either
				 * success of failure This method will throw
				 * IllegalStateException if the requried request parameter is
				 * not passed by conversation service.
				 */
				if (businessHitRequested)
					dataFetchResult = getBusinessData(actionRequested, context);
				if (transferRequested)
					dataFetchResult = "success";

				/*
				 * After business application hit, this parameter will need to
				 * reset in context
				 */
				context.put("actionRequested", null);

				/*
				 * After business application hit, session ID will be maintained
				 * in conversation context to manage cookies
				 */
				context.put("sessionID", sessionID);

				/*
				 * After business application hit, this parameter will need to
				 * reset in context
				 */
				context.put("informationRequested", null);

				/*
				 * After business application hit, this parameter will need to
				 * reset in context
				 */
				if (businessHitRequested)
					context.put("businessHitRequested", !businessHitRequested);

				/*
				 * After agent data transfer application hit, this parameter
				 * will need to reset in context
				 */
				if (transferRequested)
					context.put("transferRequested", !transferRequested);

				/*
				 * Intent will be updated and sent to conversation service to
				 * drive the dialog. Possible values are:
				 * identify_success/identify_failure
				 * getProfile_success/getProfile_failure
				 * acctStatus_success/acctStatus_failure This will be computed
				 * as a concatenation of actionRequested+Success/Failure.
				 */
				intent = actionRequested + "_" + dataFetchResult;

				/*
				 * 1. Construct a new request with the above intent 2. Use the
				 * updated context object 3. Set confidence manually to 100%
				 * (1.0) 4. Execute service call 5. Get result from service call
				 * 6. update the context map
				 */
				proxyRequestMsg = new MessageRequest.Builder().intent(new Intent(intent, 1.0)).context(context).build();
				serviceCall = service.message(workspaceid, proxyRequestMsg);
				conversationResponseMsg = serviceCall.execute();
				context = conversationResponseMsg.getContext();

				/*
				 * businessHitRequested will be included included in context by
				 * conversation If true, business application hit will be
				 * performed again After business application hit, this
				 * parameter will need to reset in context
				 */
				businessHitRequested = context.containsKey("businessHitRequested")
						? (Boolean) context.get("businessHitRequested") : false;

				/*
				 * transferRequested will be included included in context by
				 * conversation This ideally will have to be false by now, since
				 * transferRequested can be true only on one occasion
				 */
				transferRequested = context.containsKey("transferRequested")
						? (Boolean) context.get("transferRequested") : false;

				/*
				 * Conversation will set this to 'yes' after receiving
				 * tranferToAgent_success intent and playing pre-transfer
				 * message
				 */
				vgwTransfer = context.containsKey("vgwTransfer") ? (String) context.get("vgwTransfer") : "no";

				/*
				 * Transfer destination is hard-coded for POC. This must in-turn
				 * come from business application
				 */
				if ("yes".equals(vgwTransfer))
					context.put("vgwTransferTarget", "sip:8002@ped.servion.com");

			}

		} catch (EmptyBodyException exception) {

			/*
			 * This exception is thrown when post body is empty.
			 */
			logger.error("Request from Voice Gateway is empty!", exception);

			/*
			 * upon getting this exception, return null to SIP Orchestrator
			 * since there is no context, fallback is not possible.
			 */
			conversationResponseMsg = new MessageResponse();

		} catch (Exception exception) {

			if (exception instanceof BusinessAppCommunicationException) {
				/*
				 * Indicates communication with business layer failed. Please debug getBusinessData method & controllerCall method. 
				 */
				logger.error("Communication with business layer failed!", exception);
			} else {
				/*
				 * This is a generic catcher.
				 */
				logger.error("Looks like something went wrong!", exception);
			}
			/*
			 * Upon getting any exception, play generic error message and listen
			 * for caller input.
			 */
			updateTextForFailureResponse(conversationResponseMsg);

		} finally {

			addCommonVGParams(conversationResponseMsg);

			if (logger.isInfoEnabled()) {
				/*
				 * SEND_SIP_CALL_ID_TO_CONVERSATION in docker-compose has to be
				 * true. the SIP call ID is passed to the Conversation in this
				 * state variable: vgwSIPCallID MDC update will be used as key
				 * for ELK Monitoring.
				 */
				if (proxyRequestMsg.context() != null && proxyRequestMsg.context().containsKey("vgwSIPCallID"))
					MDC.put("vgwSIPCallID", proxyRequestMsg.context().get("vgwSIPCallID"));
				logger.info(conversationResponseMsg.toString());
				if (MDC.get("vgwSIPCallID") != null)
					MDC.remove("vgwSIPCallID");
			}
		}

		return conversationResponseMsg.toString();

	}

	/**
	 * This method will format the URL with the request parameters and invoke
	 * the controller. The returned data will be parsed and the context will be
	 * updated with the required details that will be used by conversation
	 * service.
	 * 
	 * @param actionRequested
	 * @param context
	 */
	private String getBusinessData(String actionRequested, Map<String, Object> context)
			throws BusinessAppCommunicationException {

		/*
		 * This list will hold the request parameters to be included in the
		 * URLs. The list will be converted to var-args and passed to
		 * String.format to build full URL
		 */
		List<String> requestParameters = new ArrayList<String>();

		/*
		 * Holds the formated URL with the required request parameters
		 */
		String controllerURL = "";

		/*
		 * Conversation service will collect inputs (identifierNumber,
		 * secretNumber & accountNumber) and pass along the context. logout
		 * doesn't require any request parameter and hence no specific handling
		 * to add request parameters.
		 */

		if (context.get("requestParam") != null) {
			Object requestParam = context.get("requestParam");
			if (requestParam != null && requestParam instanceof Double)
				requestParam = Double.toString((Double) requestParam);
			requestParameters.add((String) requestParam);
			context.remove("requestParam");
		}

		/*
		 * This will be used to pull specific information within an API call -
		 * for example: getting pendingDebitsAmount from MLI-4501
		 */
		if (context.get("informationRequested") != null)
			requestParameters.add((String) context.get("informationRequested"));
		else
			requestParameters.add("");

		try {
		controllerURL = String.format(urlsMap.get(actionRequested),
				requestParameters.toArray(new String[requestParameters.size()]));
		} catch(Exception exception) {
			
			/*
			 * This could happen when URL formating fails.
			 * Please note: Illegal Argument Exception was replaced for customization.
			 * 
			 */
			logger.error("URL formating failed: " + urlsMap.get(actionRequested), exception);
			return "failure";
		}
		
		return (controllerCall(controllerURL, context) ? "success" : "failure");
	}

	/**
	 * 
	 * This method will invoke the controller and get back the business data.
	 * Business data will be returned as a JSON String and includes a
	 * success/failure identifier. success/failure identifier will be based on
	 * the MLI response action code
	 * 
	 * Note: Basic implementation copied from Apache Http Client Sample and
	 * modified as required to retain session and cookies.
	 * 
	 * @param controllerURL
	 * @param context
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	private boolean controllerCall(String controllerURL, Map<String, Object> context)
			throws BusinessAppCommunicationException {

		/*
		 * Updated based on the result from URL call. Set to false in case of
		 * exceptions where in further processing could not be proceeded.
		 */
		boolean responseSuccessful = false;

		HttpClient client = HttpClientBuilder.create().build();

		HttpGet request = new HttpGet(controllerURL);

		/*
		 * JSESSIONID is included manually in cookie to stick session. This is
		 * automatically done by browsers but from a stand-alone java
		 * application this has to be done manually.
		 */
		request.addHeader("Cookie", sessionID);

		/*
		 * Execute HTTP Client Request. In case of any exceptions, catch the
		 * exception and return false to indicate failure. For a successful
		 * response, get the result and convert to JSON Object. Access the JSON
		 * object and update the required parameters in Context, that will be
		 * used by conversation service.
		 */
		HttpResponse response = null;
		String responseString = null;
		try {
			response = client.execute(request);
			/*
			 * Gets the self-contained entity from the http response Convert
			 * HTTP entity to String using Static helpers from
			 * org.apache.http.util.EntityUtils
			 */
			HttpEntity entity = response.getEntity();
			try {
				responseString = EntityUtils.toString(entity, "UTF-8");
				if (responseString == null || responseString.isEmpty()) {
					throw new BusinessAppCommunicationException();
				}
				sessionID = (sessionID == null) ? response.getHeaders("Set-Cookie")[0].getValue().split(";")[0]
						: sessionID;
			} catch (ParseException | IOException e) {
				throw e;
			}
		} catch (Exception e) {
			responseSuccessful = false;
			throw new BusinessAppCommunicationException();
		}

		/*
		 * 1. Convert response string to json object 2. Get status from response
		 * json object
		 */
		org.json.JSONObject jsonResponse = new org.json.JSONObject(responseString);
		String status = jsonResponse.getString("status");
		responseSuccessful = (status != null & status.equals("success")) ? true : false;

		/*
		 * 1. Get the output from controller as a json object 2. Get the entry
		 * set from the output json object 3. Copy <K,V> pairs from output json
		 * to context map
		 * 
		 * Due to serialization impedance, org.json library will be used. (Check
		 * application controllers)
		 */
		if (jsonResponse.has("outputs")) {
			org.json.JSONObject apiResult = jsonResponse.getJSONObject("outputs");
			Iterator<?> keys = apiResult.keys();
			while (keys.hasNext()) {
				String key = (String) keys.next();
				context.put(key, apiResult.getString(key));
			}
		}
		return responseSuccessful;
	}

	/**
	 * 
	 * This method is called to manually update the text to be played to the
	 * caller. This method, for now, is only used when something goes wrong and
	 * the caller will be played a fialure notification.
	 * 
	 * @param response
	 * @return
	 */
	private void updateTextForFailureResponse(MessageResponse response) {
		updateTextInResponse(response, "text",
				new String[] {
						"Sorry! The requested operation failed. " + "Please call us again in sometime" });
		
		if(response.getContext() != null) response.getContext().put("vgwHangUp", "Yes");
		
		return;
	}

	/**
	 * 
	 * This method is called to manually update the text to be played to the
	 * caller. This method, for now, is only used when EmptyBodyException is
	 * thrown to play a message to the caller to repeat the utterance. This is
	 * not a handling for no-input.
	 * 
	 * @param response
	 * @return
	 */
	@SuppressWarnings("unused")
	private String updateTextForEmptyResponse(MessageResponse response) {
		/*
		 * In some rare chances, conversation response could be null. For
		 * example: if communication with conversation service is interrupted.
		 * 
		 */
		if (response == null) {
			response = new MessageResponse();
			Map<String, Object> outputs = new HashMap<>();
			response.setOutput(outputs);
		}
		updateTextInResponse(response, "text",
				new String[] { "Sorry! I could not understand that. " + "Is there something else I can find for you" });
		return response.toString();
	}

	/**
	 * 
	 * This method is used to tweak the JSON object by modifying or adding new
	 * K,V to output JSON in the Response Object
	 * 
	 * @param response
	 * @param property
	 * @param values
	 * @return
	 */
	private void updateTextInResponse(MessageResponse response, String property, String[] values) {
		JsonArray array = new JsonArray();
		for (String value : values) {
			array.add(new JsonPrimitive(value));
		}
		response.getOutput().put(property, array);
		return;
	}

	/**
	 * The below listed will be treated as common VG Param and will be sent back
	 * to VG on every response from Router. The primary reason, these values are
	 * reset/removed from context every time a response is sent back to VG from
	 * Conversation. So instead of setting these in each of the nodes, we will
	 * set commonly in Router.
	 * 
	 *
	 * • vgwTransferFailedMessage • vgwConversationFailedMessage •
	 * vgwMusicOnHoldURL
	 * 
	 * Whereas , the following values need to set on the initial node in the
	 * conversation since these are not rest unless specifically removed by
	 * Conversation/Router.
	 * 
	 * • vgwAllowBargeIn • vgwAllowDTMF • vgwOneTimeAudioURL (only if required)
	 * 
	 * This method also sets -
	 * 
	 * - vgwSTTConfigSettings: API parameters for the Speech to Text service -
	 * vgwTTSConfigSettings: API parameters for the Text to Speech service
	 * 
	 * This is very important, please read developer comments before modifying
	 * this method.
	 * 
	 * Changing the configuration for the Speech to Text service causes the
	 * connection from the voice gateway to the Speech to Text service to
	 * disconnect and reconnect, which might cause the voice gateway to miss
	 * part of an utterance. Typically, the connection is reestablished while
	 * audio is streamed to the caller from the Conversation response, which
	 * avoids missing any part of an utterance unless the caller barges in
	 * quickly.
	 * 
	 * @param response
	 */
	private void addCommonVGParams(MessageResponse response) {
		if (response != null && response.getContext() != null) {

			response.getContext().put("vgwTransferFailedMessage",
					"Call Transfer Failed, Please try again later. Good bye.");
			response.getContext().put("vgwConversationFailedMessage",
					"Call Conversation Failed, Please try again later. Good bye.");

			response.getContext().put("vgwPostResponseTimeout", "5"); // time in
																		// seconds.
																		// replacement
																		// for
																		// vgwPostResponseTimeoutCount.
			/*
			 * one time audio : A URL to an audio file that is played a single
			 * time as soon as the included text is played back, such as for
			 * one-time utterances. This could be used to override
			 * vgwMusicOnHoldURL from conversation
			 */
			if (!response.getContext().containsKey("vgwOneTimeAudioURL")) {
				response.getContext().put("vgwMusicOnHoldURL",
						"https://raw.githubusercontent.com/WASdev/sample.voice.gateway.for.watson/master/audio/musicOnHoldSample.wav");
			}

			/*
			 * Set custom STT Params as required. These will override the
			 * parameters set by conversation service.
			 */
			JsonObject vgwSTTConfigSettings = new JsonObject();
			JsonObject vgwSTTConfigParams = new JsonObject();
			/* Add more STT Settings here - Start */
			vgwSTTConfigParams.addProperty("smartFormatting", true);
			/* Add more STT Settings here - End */
			vgwSTTConfigSettings.add("config", vgwSTTConfigParams);

			/*
			 * Set custom TTS Params as required. These will override the
			 * parameters set by conversation service.
			 */
			JsonObject vgwTTSConfigSettings = new JsonObject();
			JsonObject vgwTTSConfigParams = new JsonObject();
			/* Add more TTS Settings here - Start */
			vgwTTSConfigParams.addProperty("voice", "es-ES_LauraVoice");
			/* Add more TTS Settings here - End */
			vgwTTSConfigSettings.add("config", vgwTTSConfigParams);

			/*
			 * The below statement is commented out since this will reset the WS
			 * Connection to Media Relay. Do this only when highly required such
			 * as language change, profanity update, mask output etc...
			 */
			response.getContext().put("vgwSTTConfigSettings", vgwSTTConfigSettings);
			response.getContext().put("vgwTTSConfigSettings", vgwTTSConfigSettings);

		}
	}

}
